# 100个人围成一圈，每个人有一个编码，编号从1开始到100。
# 他们从1开始依次报数，报到为M的人自动退出圈圈，然后下一个人接着从1开始报数，直到剩余的人数小于M。
# 请问最后剩余的人在原先的编号为多少？
m = int(input())
def josephus(arr,m,count):#count相当于报数问题的n
    nxt =[]
    for i in arr:
        if count == m+1:
            count=1
        if count % m !=0:#每次田间count%m不等于0的人，因为count%m等于0的人会被删除
            nxt.append(i)
        count +=1
    if len(nxt)>=m:
        return josephus(nxt,m,count)
        #报数是三，理论上会留下两个人，顾要一直迭代到整个list中只剩下（m-1）个人
    else:
        return ",".join(map(str,nxt))

if m <= 1 or m>= 100:
    print("ERROR!")
else:
    arr = [i for i in range(1,101)]
    print(josephus(arr,m,1))

# 这个代码使用了递归的方法来模拟约瑟夫环的过程。让我来解释一下其迭代过程：
# josephus 函数接收三个参数：arr（表示当前剩余的人的编号列表）、m（表示报数的规则）、count（表示当前报数的次数）。
# 在每一轮迭代中，代码会遍历当前剩余的人的编号列表 arr。
# 对于每个人，程序会判断当前的报数次数 count 是否等于 m+1，如果是，则将 count 重新置为 1。
# 如果当前的报数次数 count 不是 m 的倍数（即不是需要删除的人），那么这个人将被保留在剩余的人中，加入到下一轮的 nxt 列表中。
# 当遍历完所有人之后，判断剩余人数是否大于等于 m。如果是，则说明还需要继续进行下一轮的约瑟夫环操作，于是递归调用 josephus 函数，并传入下一轮的参数：nxt 作为剩余的人的编号列表、m 作为报数的规则、1 作为重新计数的起始值。
# 如果剩余人数小于 m，则说明所有人都已经被删除，此时直接返回剩余的人的编号列表，即完成了约瑟夫环的过程。
# 最终，程序返回的结果是剩余的人的编号列表（以逗号分隔），表示最后剩余的人的编号。
